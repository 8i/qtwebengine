#!/usr/bin/env python

import glob
import os
import subprocess
import sys

#FIXME(pierre): mandatory until we have a git submodule, for now we can't guess where the chromium checkout lives.
if "CHROMIUM_SRC_DIR" not in os.environ:
  print "Please set the environment variable CHROMIUM_SRC_DIR to point to your checkout of chromium's 'src' directory"
  sys.exit(1)

chrome_src = os.path.abspath(os.environ.get('CHROMIUM_SRC_DIR'));
script_dir = os.path.abspath(os.path.join(chrome_src, 'build'));
if not os.path.isdir(script_dir):
  print script_dir + " is not a valid directory"
  sys.exit(1)

sys.path.insert(0, script_dir)
import gyp_helper
sys.path.insert(0, os.path.join(chrome_src, 'tools', 'gyp', 'pylib'))
import gyp

# Add paths so that pymod_do_main(...) can import files.
sys.path.insert(1, os.path.join(chrome_src, 'tools', 'grit'))
sys.path.insert(1, os.path.join(chrome_src, 'third_party', 'WebKit',
    'Source', 'WebCore', 'WebCore.gyp', 'scripts'))


def additional_include_files(args=[]):
  """
  Returns a list of additional (.gypi) files to include, without
  duplicating ones that are already specified on the command line.
  """
  # Determine the include files specified on the command line.
  # This doesn't cover all the different option formats you can use,
  # but it's mainly intended to avoid duplicating flags on the automatic
  # makefile regeneration which only uses this format.
  specified_includes = set()
  for arg in args:
    if arg.startswith('-I') and len(arg) > 2:
      specified_includes.add(os.path.realpath(arg[2:]))

  result = []
  def AddInclude(path):
    if os.path.realpath(path) not in specified_includes:
      result.append(path)

  # Always include common.gypi.
  AddInclude(os.path.join(script_dir, 'common.gypi'))

  # Optionally add supplemental .gypi files if present.
  supplements = glob.glob(os.path.join(chrome_src, '*', 'supplement.gypi'))
  for supplement in supplements:
    AddInclude(supplement)

  return result

# TODO: later we probably want to hook that up with qmake to allow shadow builds. (Might not play nice with the rest of chromium though)
def get_output_dir():
  outdir = os.path.join(os.getcwd(), "out") # Hardcode for now
  if not os.path.isdir(outdir):
    os.mkdir(outdir)

  return outdir

if __name__ == '__main__':
  args = sys.argv[1:]

  gyp_helper.apply_chromium_gyp_env()

  # This could give false positives since it doesn't actually do real option
  # parsing.  Oh well.
  gyp_file_specified = False
  for arg in args:
    if arg.endswith('.gyp'):
      gyp_file_specified = True
      break

  if not gyp_file_specified:
      args.append(os.path.join(os.getcwd(), 'blinq.gyp'))

  args.extend(['-I' + i for i in additional_include_files(args)])

  # There shouldn't be a circular dependency relationship between .gyp files,
  # but in Chromium's .gyp files, on non-Mac platforms, circular relationships
  # currently exist.  The check for circular dependencies is currently
  # bypassed on other platforms, but is left enabled on the Mac, where a
  # violation of the rule causes Xcode to misbehave badly.
  # TODO(mark): Find and kill remaining circular dependencies, and remove this
  # option.  http://crbug.com/35878.
  # TODO(tc): Fix circular dependencies in ChromiumOS then add linux2 to the
  # list.
  if sys.platform not in ('darwin',):
    args.append('--no-circular-check')

  #### HACKS START HERE #####

  args.extend(['--generator-output', os.path.abspath(get_output_dir())])
  args.extend(['-Goutput_dir='+ os.path.abspath(get_output_dir())])
  args.extend(['-D', 'chromium_src_dir=' + chrome_src])
  args.extend(['-D', 'webkit_src_dir=' + chrome_src + '/third_party/WebKit'])
  args.extend(["--depth=" + chrome_src])
  if "BLINQ_GYP_DEBUG" in os.environ:
    args.append("--check")
    args.append("-d all")
    print args

  ###################################

  print 'Updating projects from gyp files...'
  #sys.stdout.flush()

  # Off we go...
  sys.exit(gyp.main(args))
